# 加密密钥未初始化问题修复说明

## 问题描述

在使用谷歌浏览器的正常窗口和隐私窗口分别注册两个账号（如 google1 和 google2）后，当他们互相发送消息时，出现"加密密钥未初始化，请稍后重试"的错误，无法发送消息。

## 根本原因

这个问题有**两个主要原因**：

### 1. 重复的 WebSocket 连接（主要原因）

- **UserList 组件和 ChatWindow 组件各自创建了独立的 WebSocket 连接**
- 服务器使用 `Map<userId, WebSocket>` 存储在线用户
- **同一个 userId 的后连接会覆盖先连接的 WebSocket**
- 当用户从列表进入聊天时：
  1. UserList 的 WebSocket 先建立连接
  2. ChatWindow 的 WebSocket 后建立连接，覆盖了前者
  3. 密钥交换消息发送到 ChatWindow 的 WebSocket
  4. 但接收方的消息处理器可能在错误的 WebSocket 上监听
  5. 导致密钥交换失败

### 2. 时序竞争问题（次要原因）

- WebSocket 连接和密钥初始化并行执行
- 密钥初始化依赖 WebSocket 连接状态
- 但无法保证 WebSocket 在密钥初始化前完成连接
- 第一个用户生成 AES 密钥并尝试通过 WebSocket 发送给对方
- 如果此时 WebSocket 还未完全建立连接，密钥发送失败
- 双方都是新用户时，没有预先交换的密钥，时序问题最容易暴露

## 修复方案

### 1. 创建全局 WebSocket Context（核心修复）

**问题**：多个组件创建重复的 WebSocket 连接导致消息路由错误

**解决**：创建 `WebSocketContext` 提供单一的全局 WebSocket 连接

```javascript
// src/contexts/WebSocketContext.jsx
export function WebSocketProvider({ children }) {
  const [ws, setWs] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const messageHandlersRef = useRef(new Set());

  // 添加消息处理器
  const addMessageHandler = useCallback((handler) => {
    messageHandlersRef.current.add(handler);
    return () => {
      messageHandlersRef.current.delete(handler);
    };
  }, []);

  // 单一的 WebSocket 连接
  useEffect(() => {
    const websocket = new WebSocket(WS_URL);
    
    websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      // 分发消息给所有注册的处理器
      messageHandlersRef.current.forEach((handler) => {
        handler(data);
      });
    };
    
    setWs(websocket);
  }, []);

  return (
    <WebSocketContext.Provider value={{ ws, isConnected, addMessageHandler }}>
      {children}
    </WebSocketContext.Provider>
  );
}
```

### 2. 在 App.js 中使用 WebSocket Provider

```javascript
// 包裹所有需要 WebSocket 的组件
return (
  <WebSocketProvider>
    {selectedUser ? (
      <ChatWindow selectedUser={selectedUser} onBack={handleBackToList} />
    ) : (
      <UserList onSelectUser={handleSelectUser} />
    )}
  </WebSocketProvider>
);
```

### 3. 组件中使用共享的 WebSocket

**UserList 组件**：
```javascript
const { addMessageHandler } = useWebSocket();

useEffect(() => {
  const removeHandler = addMessageHandler((data) => {
    if (data.type === 'onlineUsers') {
      setOnlineUserIds(data.userIds);
    }
  });
  return removeHandler;
}, [addMessageHandler]);
```

**ChatWindow 组件**：
```javascript
const { ws, isConnected, addMessageHandler } = useWebSocket();

useEffect(() => {
  const handleMessage = async (data) => {
    if (data.type === 'keyExchange') {
      // 处理密钥交换
    } else if (data.type === 'message') {
      // 处理消息
    }
  };
  
  const removeHandler = addMessageHandler(handleMessage);
  return removeHandler;
}, [addMessageHandler]);
```

### 4. 密钥发送重试机制

```javascript
// 等待WebSocket准备就绪，然后发送密钥
const sendKey = () => {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'keyExchange',
      from: currentUserId,
      to: selectedUser.id,
      encryptedKey: encryptedKey,
    }));
    console.log('已发送加密的AES密钥');
  } else {
    // WebSocket还没准备好，稍后重试
    console.log('WebSocket未就绪，1秒后重试发送密钥...');
    setTimeout(sendKey, 1000);
  }
};
sendKey();
```

### 5. 添加密钥就绪状态追踪

```javascript
// 新增状态
const [isKeyReady, setIsKeyReady] = useState(false);

// 设置密钥时同时更新就绪状态
setAesKey(key);
setIsKeyReady(true);
```

### 6. 更好的用户反馈

- **状态显示**：在聊天头部显示连接和密钥状态
  - `🔐 安全连接`：WebSocket 已连接且密钥已就绪
  - `🔄 密钥初始化中...`：WebSocket 已连接但密钥正在初始化
  - `连接中...`：WebSocket 正在连接

- **发送按钮**：只有在密钥就绪时才启用
  ```javascript
  disabled={!isConnected || !isKeyReady || !inputMessage.trim()}
  ```

- **错误提示**：更明确的错误信息
  ```javascript
  if (!aesKey || !isKeyReady) {
    alert('加密密钥正在初始化中，请稍等片刻后重试');
    return;
  }
  ```

## 测试步骤

1. **启动服务器**
   ```bash
   cd /home/lyanta/secureChat/secure-chat-system/server
   node server.js
   ```

2. **启动客户端**
   ```bash
   cd /home/lyanta/secureChat/secure-chat-system/client
   npm start
   ```

3. **测试场景**
   - 打开正常浏览器窗口，注册账号 `google1`
   - 打开隐私浏览器窗口，注册账号 `google2`
   - 在 `google1` 中选择 `google2` 开始聊天
   - 观察状态变化：`连接中...` → `🔄 密钥初始化中...` → `🔐 安全连接`
   - 发送消息，应该可以成功发送和接收

4. **验证密钥交换**
   - 打开浏览器控制台（F12）
   - 查看日志输出：
     - "已生成新的AES密钥"
     - "已发送加密的AES密钥"（发送方）
     - "已接收并保存AES密钥"（接收方）

## 关键改进点

1. ✅ **全局 WebSocket 连接**：消除重复连接，确保消息路由正确（最重要的修复）
2. ✅ **消息处理器模式**：多个组件可以共享同一个 WebSocket 并各自处理消息
3. ✅ **解决时序问题**：确保 WebSocket 连接后才发送密钥
4. ✅ **重试机制**：密钥发送失败时自动重试
5. ✅ **状态管理**：清晰的密钥就绪状态追踪
6. ✅ **用户体验**：实时显示连接和密钥状态
7. ✅ **错误处理**：更友好的错误提示

## 注意事项

- 密钥交换需要**双方都在线**才能完成
- 如果对方离线，发送方会生成并保存密钥，但无法立即交换
- 下次对方上线时，仍需要重新发起密钥交换
- 浏览器的 localStorage 会保存密钥，刷新页面后密钥依然有效

